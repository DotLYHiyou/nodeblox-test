"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpRequest = void 0;
const axios_1 = __importDefault(require("axios"));
const Globals_1 = require("../Util/Globals");
const https_1 = require("https");
const FastLogTool_1 = require("../Tools/FastLogTool");
(0, FastLogTool_1.FASTFLAG)('Debug');
(0, FastLogTool_1.DYNAMIC_FASTINTVARIABLE)('HttpRequestTimeoutMs', 10000);
(0, FastLogTool_1.DYNAMIC_FASTSTRINGVARIABLE)('HttpRequestTimedOutErrorMessage', 'The request failed because it timed out.');
/**
 * @internal
 */
class HttpRequest {
    constructor() {
        this.additionalHeaders = {};
        this.doNotParse = false;
    }
    async execute(_dataStoreService) {
        return new Promise((resumeFunction, errorFunction) => {
            const http = {
                headers: {
                    ...Globals_1.Globals.GlobalHeaders(),
                    ...this.additionalHeaders,
                },
                transformResponse: (resp, headers) => {
                    if (this.doNotParse)
                        return resp;
                    if (headers && headers['content-type'] && headers['content-type'].includes('json'))
                        try {
                            return JSON.parse(resp);
                        }
                        catch {
                            return resp; // TODO Report an error here.
                        }
                    return resp;
                },
                httpsAgent: new https_1.Agent({ rejectUnauthorized: !FastLogTool_1.FFlag['Debug'] }),
                timeout: (0, FastLogTool_1.DFInt)('HttpRequestTimeoutMs'),
                timeoutErrorMessage: (0, FastLogTool_1.DFString)('HttpRequestTimedOutErrorMessage'),
            };
            if (HttpRequest._lastCsrfToken && HttpRequest._lastCsrfToken.length > 0 && !http.headers['x-csrf-token'])
                http.headers['x-csrf-token'] = HttpRequest._lastCsrfToken;
            if (!this.method)
                axios_1.default.post(this.url, this.postData === undefined || this.postData.length === 0 ? ' ' : this.postData, http)
                    .then((res) => {
                    resumeFunction(res);
                })
                    .catch((e) => {
                    if (e.response !== undefined) {
                        if (e.response.status === 403) {
                            const token = e.response.headers['x-csrf-token'];
                            if (token !== undefined) {
                                this.additionalHeaders['x-csrf-token'] = token;
                                HttpRequest._lastCsrfToken = token;
                                return resumeFunction(this.execute(_dataStoreService));
                            }
                        }
                    }
                    errorFunction(e);
                });
            else if (this.method === 'GET')
                axios_1.default.get(this.url, http)
                    .then((res) => {
                    resumeFunction(res);
                })
                    .catch((e) => {
                    errorFunction(e);
                });
            else if (this.method === 'DELETE')
                axios_1.default.delete(this.url, http)
                    .then((res) => {
                    resumeFunction(res);
                })
                    .catch((e) => {
                    errorFunction(e);
                });
        });
    }
}
exports.HttpRequest = HttpRequest;
