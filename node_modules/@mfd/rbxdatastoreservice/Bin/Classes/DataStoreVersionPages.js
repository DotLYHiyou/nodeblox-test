"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreVersionPages = void 0;
const DataStoreService_1 = require("./Services/DataStoreService");
const HttpRequest_1 = require("./HttpRequest");
const Pages_1 = require("./Pages");
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
const DataStore_1 = require("./DataStore");
const DataStoreObjectVersionInfo_1 = require("./DataStoreObjectVersionInfo");
const ErrorHelper_1 = require("../Helpers/ErrorHelper");
const ErrorType_1 = require("../Enumeration/ErrorType");
/**
 * A special type of [Pages](https://developer.roblox.com/en-us/api-reference/class/Pages) object whose pages contain [DataStoreObjectVersionInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreObjectVersionInfo) instances from a [GlobalDataStore](https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore).
 * [Pages:GetCurrentPage](https://developer.roblox.com/en-us/api-reference/function/Pages/GetCurrentPage) can be used to retrieve an array of the [DataStoreObjectVersionInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreObjectVersionInfo) instances.
 *
 * ---
 * SEE ALSO
 * --------
 * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
 *
 * ---
 */
class DataStoreVersionPages extends Pages_1.Pages {
    /**
     * @internal
     */
    constructor(ds, requestUrl) {
        super();
        this.ds = ds;
        this.requestUrl = requestUrl;
        this.exclusiveStartKey = '';
    }
    GetCurrentPage() {
        return this.currentPage;
    }
    /**
     * @internal
     */
    async FetchNextChunk() {
        return new Promise((resumeFunction, errorFunction) => {
            const request = new HttpRequest_1.HttpRequest();
            const ds = this.ds;
            if (!ds) {
                return errorFunction('DataStore no longer exists');
            }
            request.url =
                this.exclusiveStartKey.length === 0
                    ? this.requestUrl
                    : `${this.requestUrl.toString()}&exclusiveStartKey=${this.exclusiveStartKey.toString()}`;
            request.requestType = DataStoreService_1.RequestType.GET_SORTED_ASYNC_PAGE;
            request.method = 'GET';
            ExecutionHelper_1.ExectionHelper.ExecuteGetSorted(request)
                .then((r) => {
                const [success, result] = DataStore_1.DataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                const versions = result['versions'];
                if (!Array.isArray(versions))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const newValue = [];
                for (let i = 0; i < versions.length; i++) {
                    const createdTimeIso = versions[i]['createdTime'];
                    if (createdTimeIso === undefined)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                    const isDeleted = versions[i]['deleted'];
                    if (typeof isDeleted !== 'boolean' && isDeleted !== null)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                    const version = versions[i]['version'];
                    if (version === undefined)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                    newValue.push(new DataStoreObjectVersionInfo_1.DataStoreObjectVersionInfo(new Date(createdTimeIso).getTime(), isDeleted, version));
                }
                this.exclusiveStartKey = result['lastReturnedKey'];
                this.currentPage = newValue;
                return resumeFunction();
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    /**
     * Iterates to the next page in the pages object,
     * if possible.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async AdvanceToNextPageAsync() {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (this.finished) {
                console.error('No pages to advance to');
                return resumeFunction();
            }
            await this.FetchNextChunk()
                .then(() => resumeFunction())
                .catch((ex) => errorFunction(ex));
        });
    }
}
exports.DataStoreVersionPages = DataStoreVersionPages;
