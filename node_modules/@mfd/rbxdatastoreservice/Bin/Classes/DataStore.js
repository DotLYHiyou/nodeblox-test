"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStore = void 0;
const FastLogTool_1 = require("../Tools/FastLogTool");
const Globals_1 = require("../Util/Globals");
const GlobalDataStore_1 = require("./GlobalDataStore");
const HttpRequest_1 = require("./HttpRequest");
const crypto_js_1 = __importDefault(require("crypto-js"));
const enc_base64_1 = __importDefault(require("crypto-js/enc-base64"));
const SortDirection_1 = require("../Enumeration/SortDirection");
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
const InputHelper_1 = require("../Helpers/InputHelper");
const DataStoreService_1 = require("./Services/DataStoreService");
const ApiDataStoresUrlConstruction_1 = require("../Constructors/ApiDataStoresUrlConstruction");
const DataStoreKeyInfo_1 = require("./DataStoreKeyInfo");
const DataStoreKeyPages_1 = require("./DataStoreKeyPages");
const DataStoreVersionPages_1 = require("./DataStoreVersionPages");
const ErrorHelper_1 = require("../Helpers/ErrorHelper");
const ErrorType_1 = require("../Enumeration/ErrorType");
(0, FastLogTool_1.LOGGROUP)('DataStore');
(0, FastLogTool_1.LOGVARIABLE)('Debug', 0);
(0, FastLogTool_1.DYNAMIC_FASTINT)('DataStoreMaxValueSize');
(0, FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE)('DataStore2CheckObjectKeyForScope', false);
(0, FastLogTool_1.DYNAMIC_FASTINTVARIABLE)('DataStoreMaxMetadataSize', 300);
(0, FastLogTool_1.DYNAMIC_FASTINTVARIABLE)('DataStoreMaxUserIdsLimit', 4);
class DataStore extends GlobalDataStore_1.GlobalDataStore {
    /**
     * @internal
     */
    constructor(name, scope, legacy, allScopes) {
        super(name, scope, legacy, allScopes);
    }
    /**
     * @internal
     */
    urlApiPath() {
        return 'v2/persistence';
    }
    /**
     * @internal
     */
    runTransformFunction(key, transformFunc) {
        return new Promise(async (resumeFunction, errorFunction) => {
            let result;
            let metadata;
            let userIds;
            const [data, keyInfo] = await this.GetAsync(key);
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Running transform function, input: %s', JSON.stringify(data));
            try {
                let transformResult = transformFunc(data, keyInfo);
                // going on a stretch here because the user may return an array
                // will have to document it for them, because tuples suck!
                if (Array.isArray(transformResult)) {
                    result = transformResult[0];
                    metadata = transformResult[1];
                    userIds = transformResult[2];
                }
                else {
                    result = transformResult;
                }
            }
            catch (e) {
                return errorFunction(e);
            }
            if (result === undefined || result.size === 0 || result === null) {
                (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Transform function returned nil, update is cancelled');
                return errorFunction('Transform function returned nil, update is cancelled');
            }
            if (userIds !== undefined) {
                if (!Array.isArray(userIds))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.USERID_ATTRIBUTE_INVALID));
                if (userIds.length > (0, FastLogTool_1.DFInt)('DataStoreMaxUserIdsLimit'))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.USERID_LIMIT_TOO_LARGE));
            }
            if (userIds)
                if (metadata !== undefined) {
                    if (typeof metadata !== 'object')
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.METATADA_ATTRIBUTE_INVALID));
                    if (JSON.stringify(metadata).length > (0, FastLogTool_1.DFInt)('DataStoreMaxMetadataSize'))
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.METADATA_TOO_LARGE));
                }
            if (!this.checkValueIsAllowed(result))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof result));
            const [serialized, v] = GlobalDataStore_1.GlobalDataStore.serializeVariant(result);
            if (!serialized)
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof result));
            if (v.length > (0, FastLogTool_1.DFInt)('DataStoreMaxValueSize'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.VALUE_TOO_LARGE));
            const request = new HttpRequest_1.HttpRequest();
            request.url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructObjectOpUrl(this.nameUrlEncodedIfNeeded, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, Globals_1.Globals.UniverseID);
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            request.postData = v.toString();
            request.additionalHeaders['Content-MD5'] = enc_base64_1.default.stringify(crypto_js_1.default.MD5(request.postData));
            request.additionalHeaders['Content-Type'] = '*/*';
            request.additionalHeaders['If-Match'] = JSON.stringify(keyInfo.Version);
            if (metadata)
                request.additionalHeaders['Roblox-Object-Attributes'] = JSON.stringify(metadata || {});
            if (userIds)
                request.additionalHeaders['Roblox-Object-UserIds'] = JSON.stringify(userIds);
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] SetIf on key: %s`, key);
            this.logLongValue(v);
            /*
                Expected response:
                {
                      "version": "OBJECT_VERSION_HERE", // The version of the object
                      "deleted": false, // Was the key deleted, only works if DELETE on endpoint
                      "contentLength": 0, // The absolute content length
                      "createdTime": "VERSION_CREATED_DATE_HERE", // The date that this version was created in an ISO string
                      "objectCreatedTime": "OBJECT_CREATED_DATE" // The date thet the key was created.
                }
                */
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                const [success, res] = GlobalDataStore_1.GlobalDataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(result);
                }
                const objectCreatedTimeIso = res['objectCreatedTime'];
                if (objectCreatedTimeIso === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const createdTimeIso = res['createdTime'];
                if (createdTimeIso === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const version = res['version'];
                if (version === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                resumeFunction([
                    res,
                    new DataStoreKeyInfo_1.DataStoreKeyInfo(new Date(objectCreatedTimeIso).getTime(), new Date(createdTimeIso).getTime(), version, metadata, userIds),
                ]);
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    /////////////// LEGACY MEMBERS ///////////////
    async GetAsync(key) {
        return new Promise(async (resumeFunction, errorFunction) => {
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] GetAsync on key %s`, key);
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            if (this.allScopes) {
                if ((0, FastLogTool_1.DFFlag)('DataStore2CheckObjectKeyForScope')) {
                    if (key.split('/').length < 2)
                        return errorFunction('The provided object key is invalid.');
                }
            }
            const request = new HttpRequest_1.HttpRequest();
            request.key = key;
            request.owner = this;
            request.method = 'GET';
            request.url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructObjectOpUrl(this.nameUrlEncodedIfNeeded, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, Globals_1.Globals.UniverseID);
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request)
                .then((response) => {
                let [didDeserialize, result] = DataStore.deserializeVariant(response.data);
                if (!didDeserialize)
                    result = response.data;
                const objectCreatedTimeIso = response.headers['roblox-object-created-time'];
                if (objectCreatedTimeIso === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const objectVersionCreatedTime = response.headers['roblox-object-version-created-time'];
                if (objectVersionCreatedTime === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const version = response.headers['etag'];
                if (version === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                let objectAttributes = response.headers['roblox-object-attributes'];
                if (objectAttributes === undefined)
                    objectAttributes = '{}';
                let objectUserIds = response.headers['roblox-object-userids'];
                if (objectUserIds === undefined)
                    objectUserIds = '[]';
                return resumeFunction([
                    result,
                    new DataStoreKeyInfo_1.DataStoreKeyInfo(new Date(objectCreatedTimeIso).getTime(), new Date(objectVersionCreatedTime).getTime(), JSON.parse(version), new Map(Object.entries(JSON.parse(objectAttributes))), JSON.parse(objectUserIds)),
                ]);
            })
                .catch((reason) => {
                if (reason.response) {
                    if (reason.response.data instanceof Object) {
                        const errors = reason.response.data['errors'];
                        if (Array.isArray(errors) && errors.length > 0) {
                            if (errors[0].code === 11)
                                return resumeFunction([undefined, undefined]);
                        }
                    }
                }
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    async SetAsync(key, value, userIds = [], options = undefined) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            if (this.allScopes) {
                if ((0, FastLogTool_1.DFFlag)('DataStore2CheckObjectKeyForScope')) {
                    if (key.split('/').length < 2)
                        return errorFunction('The provided object key is invalid.');
                }
            }
            if (value === undefined)
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_STORE_DATA_IN_DATASTORE, typeof value));
            if (!this.checkValueIsAllowed(value))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof value));
            const [success2, v] = GlobalDataStore_1.GlobalDataStore.serializeVariant(value);
            if (!success2)
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof value));
            if (v.length > (0, FastLogTool_1.DFInt)('DataStoreMaxValueSize'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.VALUE_TOO_LARGE));
            if (userIds.length > (0, FastLogTool_1.DFInt)('DataStoreMaxUserIdsLimit'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.USERID_LIMIT_TOO_LARGE));
            if (options && JSON.stringify(options.GetMetadata()).length > (0, FastLogTool_1.DFInt)('DataStoreMaxMetadataSize'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.METADATA_TOO_LARGE));
            const request = new HttpRequest_1.HttpRequest();
            request.url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructObjectOpUrl(this.nameUrlEncodedIfNeeded, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, Globals_1.Globals.UniverseID);
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            request.postData = v.toString();
            request.additionalHeaders['Content-MD5'] = enc_base64_1.default.stringify(crypto_js_1.default.MD5(request.postData));
            request.additionalHeaders['Content-Type'] = '*/*';
            request.additionalHeaders['Roblox-Object-Attributes'] = JSON.stringify(options ? options.GetMetadata() : {});
            request.additionalHeaders['Roblox-Object-UserIds'] = JSON.stringify(userIds);
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] SetAsync on key: %s`, key);
            this.logLongValue(v);
            /*
            Expected response:
            {
                "version": "OBJECT_VERSION_HERE", // The version of the object
                "deleted": false, // Was the key deleted, only works if DELETE on endpoint
                "contentLength": 0, // The absolute content length
                "createdTime": "VERSION_CREATED_DATE_HERE", // The date that this version was created in an ISO string
                "objectCreatedTime": "OBJECT_CREATED_DATE" // The date thet the key was created.
            }
            */
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                const [success, result] = GlobalDataStore_1.GlobalDataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(value);
                }
                const version = result['version'];
                if (version === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                resumeFunction(version);
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    async RemoveAsync(key) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            if (this.allScopes) {
                if ((0, FastLogTool_1.DFFlag)('DataStore2CheckObjectKeyForScope')) {
                    if (key.split('/').length < 2)
                        return errorFunction('The provided object key is invalid.');
                }
            }
            const request = new HttpRequest_1.HttpRequest();
            request.url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructObjectOpUrl(this.nameUrlEncodedIfNeeded, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, Globals_1.Globals.UniverseID);
            request.owner = this;
            request.key = key;
            request.method = 'DELETE';
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((response) => {
                let [didDeserialize, result] = DataStore.deserializeVariant(response.data);
                if (!didDeserialize)
                    result = response.data;
                const objectCreatedTimeIso = response.headers['roblox-object-created-time'];
                if (objectCreatedTimeIso === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const objectVersionCreatedTime = response.headers['roblox-object-version-created-time'];
                if (objectVersionCreatedTime === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const version = response.headers['etag'];
                if (version === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                let objectAttributes = response.headers['roblox-object-attributes'];
                if (objectAttributes === undefined)
                    objectAttributes = '{}';
                let objectUserIds = response.headers['roblox-object-userids'];
                if (objectUserIds === undefined)
                    objectUserIds = '[]';
                return resumeFunction([
                    result,
                    new DataStoreKeyInfo_1.DataStoreKeyInfo(new Date(objectCreatedTimeIso).getTime(), new Date(objectVersionCreatedTime).getTime(), JSON.parse(version), new Map(Object.entries(JSON.parse(objectAttributes))), JSON.parse(objectUserIds)),
                ]);
            })
                .catch((error) => {
                if (error.response) {
                    if (error.response.data instanceof Object) {
                        const errors = error.response.data['errors'];
                        if (Array.isArray(errors) && errors.length > 0) {
                            if (errors[0].code === 11)
                                return resumeFunction([undefined, undefined]);
                        }
                    }
                }
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(error));
            });
        });
    }
    async IncrementAsync(key, delta = 1, userIds = [], options = undefined) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            if (this.allScopes) {
                if ((0, FastLogTool_1.DFFlag)('DataStore2CheckObjectKeyForScope')) {
                    if (key.split('/').length < 2)
                        return errorFunction('The provided object key is invalid.');
                }
            }
            if (userIds.length > (0, FastLogTool_1.DFInt)('DataStoreMaxUserIdsLimit'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.USERID_LIMIT_TOO_LARGE));
            if (options && JSON.stringify(options.GetMetadata()).length > (0, FastLogTool_1.DFInt)('DataStoreMaxMetadataSize'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.METADATA_TOO_LARGE));
            const request = new HttpRequest_1.HttpRequest();
            request.url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructIncrementOpUrl(this.nameUrlEncodedIfNeeded, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, Globals_1.Globals.UniverseID, delta);
            request.owner = this;
            request.additionalHeaders['Roblox-Object-Attributes'] = JSON.stringify(options ? options.GetMetadata() : {});
            request.additionalHeaders['Roblox-Object-UserIds'] = JSON.stringify(userIds);
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.INCREMENT_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((response) => {
                if (isNaN(parseFloat(response.data)))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(parseFloat(response.data) || 0);
                }
                const objectCreatedTimeIso = response.headers['roblox-object-created-time'];
                if (objectCreatedTimeIso === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const objectVersionCreatedTime = response.headers['roblox-object-version-created-time'];
                if (objectVersionCreatedTime === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const version = response.headers['etag'];
                if (version === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                let objectAttributes = response.headers['roblox-object-attributes'];
                if (objectAttributes === undefined)
                    objectAttributes = '{}';
                let objectUserIds = response.headers['roblox-object-userids'];
                if (objectUserIds === undefined)
                    objectUserIds = '[]';
                resumeFunction([
                    parseFloat(response.data) || 0,
                    new DataStoreKeyInfo_1.DataStoreKeyInfo(new Date(objectCreatedTimeIso).getTime(), new Date(objectVersionCreatedTime).getTime(), version, new Map(Object.entries(JSON.parse(objectAttributes))), JSON.parse(objectUserIds)),
                ]);
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    async UpdateAsync(key, transformFunction) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Updating key %s', key);
            this.runTransformFunction(key, transformFunction)
                .then(resumeFunction)
                .catch(errorFunction);
        });
    }
    /////////////// NEW MEMBERS ///////////////
    /**
     * This function retrieves the specified key version as well as a [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) instance.
     * A version identifier can be found through [DataStore:ListVersionsAsync](https://developer.roblox.com/en-us/api-reference/function/DataStore/ListVersionsAsync) or alternatively be the identifier returned by [GlobalDataStore:SetAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/SetAsync).
     *
     * ---
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} key Key name for which the value should be updated. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @param {string} version Version number of the key for which the version info is requested
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     * @returns {[Variant, DataStoreKeyInfo]} The value of the key at the specified version and a [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) instance that includes the version number, date and time the version was created, and functions to retrieve [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId) and metadata.
     */
    async GetVersionAsync(key, version = undefined) {
        return new Promise(async (resumeFunction, errorFunction) => {
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] GetVersionAsync on key %s`, key);
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            if (this.allScopes) {
                if ((0, FastLogTool_1.DFFlag)('DataStore2CheckObjectKeyForScope')) {
                    if (key.split('/').length < 2)
                        return errorFunction('The provided object key is invalid.');
                }
            }
            const request = new HttpRequest_1.HttpRequest();
            request.key = key;
            request.owner = this;
            request.method = 'GET';
            request.url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructVersionOpUrl(this.nameUrlEncodedIfNeeded, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, Globals_1.Globals.UniverseID, version);
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request)
                .then((response) => {
                let [didDeserialize, result] = DataStore.deserializeVariant(response.data);
                if (!didDeserialize)
                    result = response.data;
                const objectCreatedTimeIso = response.headers['roblox-object-created-time'];
                if (objectCreatedTimeIso === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const objectVersionCreatedTime = response.headers['roblox-object-version-created-time'];
                if (objectVersionCreatedTime === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const version = response.headers['etag'];
                if (version === undefined)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                let objectAttributes = response.headers['roblox-object-attributes'];
                if (objectAttributes === undefined)
                    objectAttributes = '{}';
                let objectUserIds = response.headers['roblox-object-userids'];
                if (objectUserIds === undefined)
                    objectUserIds = '[]';
                return resumeFunction([
                    result,
                    new DataStoreKeyInfo_1.DataStoreKeyInfo(new Date(objectCreatedTimeIso).getTime(), new Date(objectVersionCreatedTime).getTime(), version, new Map(Object.entries(JSON.parse(objectAttributes))), JSON.parse(objectUserIds)),
                ]);
            })
                .catch((reason) => {
                if (reason.response) {
                    if (reason.response.data instanceof Object) {
                        const errors = reason.response.data['errors'];
                        if (Array.isArray(errors) && errors.length > 0) {
                            if (errors[0].code === 11)
                                return resumeFunction([undefined, undefined]);
                        }
                    }
                }
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    /**
     * This function returns a [DataStoreKeyPages](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyPages) object for enumerating through keys of a data store.
     * It accepts an optional `prefix` parameter to only locate data stores whose names start with the provided prefix.
     * If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), keys will be returned with all scopes as prefixes.
     *
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} prefix (Optional) Prefix to use for locating keys.
     * @param {number} pageSize (Optional) Number of items to be returned in each page.
     * @returns {DataStoreKeyPages} A [DataStoreKeyPages](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyPages) instance that enumerates the keys as [DataStoreKey](https://developer.roblox.com/en-us/api-reference/class/DataStoreKey) instances.
     * @yields This is a yielding function. When called, it will pause the Javascript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     * @unsafe For thread safety, this property is not safe to read in an unsynchronized thread.
     */
    async ListKeysAsync(prefix = '', pageSize = 0) {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (!this.allScopes) {
                prefix = `${this.scopeUrlEncodedIfNeeded}/${prefix}`;
            }
            const url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructListKeysUrl(this.nameUrlEncodedIfNeeded, Globals_1.Globals.UniverseID, prefix, pageSize);
            const page = new DataStoreKeyPages_1.DataStoreKeyPages(this, url);
            await page
                .AdvanceToNextPageAsync()
                .then(() => resumeFunction(page))
                .catch(errorFunction);
        });
    }
    /**
     * This function enumerates versions of the specified key in either ascending or descending order specified by an [SortDirection](https://developer.roblox.com/en-us/api-reference/enum/SortDirection) parameter.
     * It can optionally filter the returned versions by minimum and maximum timestamp.
     *
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} key Key name for the versions to list. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @param {SortDirection?} sortDirection (Optional) Enum specifying ascending or descending sort order. Default is ascending.
     * @param {number} minDate (Optional) Date after which the versions should be listed.
     * @param {number} maxDate (Optional) Date up to which the versions should be listed.
     * @param {number} pageSize (Optional) Number of items to be returned in each page.
     * @returns {DataStoreVersionPages} A [DataStoreVersionPages](https://developer.roblox.com/en-us/api-reference/class/DataStoreVersionPages) instance that enumerates all the versions of the key as [DataStoreObjectVersionInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreObjectVersionInfo) instances.
     * @yields This is a yielding function. When called, it will pause the Javascript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     * @unsafe For thread safety, this property is not safe to read in an unsynchronized thread.
     */
    async ListVersionsAsync(key, sortDirection = SortDirection_1.SortDirection.Ascending, minDate = 0, maxDate = 0, pageSize = 0) {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (this.allScopes) {
                if ((0, FastLogTool_1.DFFlag)('DataStore2CheckObjectKeyForScope')) {
                    if (key.split('/').length < 2)
                        return errorFunction('The provided object key is invalid.');
                }
            }
            const url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructListVersionsUrl(this.nameUrlEncodedIfNeeded, Globals_1.Globals.UniverseID, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, pageSize, minDate, maxDate, sortDirection);
            const page = new DataStoreVersionPages_1.DataStoreVersionPages(this, url);
            await page
                .AdvanceToNextPageAsync()
                .then(() => resumeFunction(page))
                .catch(errorFunction);
        });
    }
    /**
     * This function permanently deletes the specified version of a key. Version identifiers can be found through [DataStore:ListVersionsAsync](https://developer.roblox.com/en-us/api-reference/function/DataStore/ListVersionsAsync).
     *
     * Unlike [GlobalDataStore:RemoveAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/RemoveAsync), this function does not create a new “tombstone” version and the removed value cannot be retrieved later.
     *
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} key Key name for which a version is to be removed. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @param {string} version Version number of the key to remove.
     * @returns {void} No return.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async RemoveVersionAsync(key, version) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            if (this.allScopes) {
                if ((0, FastLogTool_1.DFFlag)('DataStore2CheckObjectKeyForScope')) {
                    if (key.split('/').length < 2)
                        return errorFunction('The provided object key is invalid.');
                }
            }
            const request = new HttpRequest_1.HttpRequest();
            request.url = ApiDataStoresUrlConstruction_1.ApiDataStoresUrlConstruction.constructVersionOpUrl(this.nameUrlEncodedIfNeeded, this.allScopes ? key : `${this.scopeUrlEncodedIfNeeded}/${key}`, Globals_1.Globals.UniverseID, version);
            request.owner = this;
            request.key = key;
            request.method = 'DELETE';
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then(() => {
                resumeFunction();
            })
                .catch((e) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(e));
            });
        });
    }
}
exports.DataStore = DataStore;
