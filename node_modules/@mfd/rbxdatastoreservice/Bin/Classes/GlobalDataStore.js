"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalDataStore = void 0;
const HttpRequest_1 = require("./HttpRequest");
const Globals_1 = require("../Util/Globals");
const FastLogTool_1 = require("../Tools/FastLogTool");
const RBXScriptConnection_1 = require("./RBXScriptConnection");
const events_1 = __importDefault(require("events"));
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
const InputHelper_1 = require("../Helpers/InputHelper");
const DataStoreService_1 = require("./Services/DataStoreService");
const UrlTool_1 = require("../Tools/UrlTool");
const ErrorHelper_1 = require("../Helpers/ErrorHelper");
const ErrorType_1 = require("../Enumeration/ErrorType");
(0, FastLogTool_1.LOGVARIABLE)('DataStore', 0);
(0, FastLogTool_1.DYNAMIC_FASTINTVARIABLE)('DataStoreMaxValueSize', 64 * 1024);
(0, FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE)('DataStoreUseNewEndpoints', true);
(0, FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE)('DataStoreNewEndpointsReturnResultIfFailedToDeserialize', true);
/**
 * A **GlobalDataStore** exposes functions for saving and loading data for the [DataStoreService](https://developer.roblox.com/en-us/api-reference/class/DataStoreService).
 * See the [Data Stores](https://developer.roblox.com/en-us/articles/Data-store) article for an in-depth guide on data structure, management, error handling, etc.
 */
class GlobalDataStore {
    /**
     * @internal
     */
    constructor(name, scope /*= 'global'*/, legacy, allScopes) {
        /**
         * @internal
         */
        this.callbacks = new Map();
        /**
         * @internal
         */
        this.CachedKeys = new Map();
        /**
         * @internal
         */
        this.CachedUsns = new Map();
        /**
         * @internal
         */
        this.isLegacy = false;
        this.isLegacy = legacy;
        this.name = name;
        this.scope = scope;
        this.nameUrlEncodedIfNeeded = this.urlEncodeIfNeeded(name);
        this.scopeUrlEncodedIfNeeded = this.urlEncodeIfNeeded(scope);
        this.serviceUrl = UrlTool_1.UrlHelper.BuildGenericPersistenceUrl(this.urlApiPath());
        this.allScopes = allScopes;
        (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Initialized Data Store, url: %s', this.serviceUrl);
    }
    /**
     * @internal
     * @todo JSON
     */
    constructPostDataForKey(key, index = 0) {
        return this.isLegacy
            ? `&qkeys[${index}].scope=${this.scopeUrlEncodedIfNeeded.toString()}&qkeys[${index}].target=&qkeys[${index}].key=${this.urlEncodeIfNeeded(key).toString()}`
            : `&qkeys[${index}].scope=${this.scopeUrlEncodedIfNeeded.toString()}&qkeys[${index}].target=${this.urlEncodeIfNeeded(key).toString()}&qkeys[${index}].key=${this.nameUrlEncodedIfNeeded.toString()}`;
    }
    /**
     * @internal
     */
    constructGetUrl() {
        const placeId = Globals_1.Globals.PlaceID;
        if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints'))
            return `${this.serviceUrl}${this.getDataStoreTypeString()}?scope=${this.scopeUrlEncodedIfNeeded.toString()}`;
        return `${this.serviceUrl}getV2?placeId=${placeId}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}`;
    }
    /**
     * @internal
     */
    constructGetV2Url(key) {
        return this.isLegacy
            ? `${this.serviceUrl}${this.getDataStoreTypeString()}?scope=${this.scopeUrlEncodedIfNeeded.toString()}&key=${this.urlEncodeIfNeeded(key).toString()}&target=`
            : `${this.serviceUrl}${this.getDataStoreTypeString()}?scope=${this.scopeUrlEncodedIfNeeded.toString()}&key=${this.nameUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}`;
    }
    /**
     * @internal
     */
    constructSetUrl(key, valueLength) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}set?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&valueLength=${valueLength}`
            : `${this.serviceUrl.toString()}set?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&valueLength=${valueLength}`;
    }
    /**
     * @internal
     */
    constructSetV2Url(key) {
        return this.isLegacy
            ? `${this.serviceUrl}${this.getDataStoreTypeString()}?key=${this.urlEncodeIfNeeded(key).toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=`
            : `${this.serviceUrl}${this.getDataStoreTypeString()}?key=${this.nameUrlEncodedIfNeeded.toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}`;
    }
    /**
     * @internal
     */
    constructSetIfUrl(key, valueLength, expectedValueLength) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}set?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&valueLength=${valueLength}&expectedValueLength=${expectedValueLength}`
            : `${this.serviceUrl.toString()}set?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&valueLength=${valueLength}&expectedValueLength=${expectedValueLength}`;
    }
    /**
     * @internal
     */
    constructSetIfV2Url(key, usn) {
        return this.isLegacy
            ? `${this.serviceUrl}${this.getDataStoreTypeString()}?key=${this.urlEncodeIfNeeded(key).toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&usn=${this.urlEncodeIfNeeded(usn)}`
            : `${this.serviceUrl}${this.getDataStoreTypeString()}?key=${this.nameUrlEncodedIfNeeded.toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&usn=${this.urlEncodeIfNeeded(usn)}`;
    }
    /**
     * @internal
     */
    constructIncrementUrl(key, delta) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}increment?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&value=${delta}`
            : `${this.serviceUrl}increment?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&value=${delta}`;
    }
    /**
     * @internal
     */
    constructIncrementV2Url(key, delta) {
        return this.isLegacy
            ? `${this.serviceUrl}${this.getDataStoreTypeString()}/increment?key=${this.urlEncodeIfNeeded(key).toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=&by=${delta}`
            : `${this.serviceUrl}${this.getDataStoreTypeString()}/increment?key=${this.nameUrlEncodedIfNeeded.toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}&by=${delta}`;
    }
    /**
     * @internal
     */
    constructRemoveUrl(key) {
        const placeId = Globals_1.Globals.PlaceID;
        return this.isLegacy
            ? `${this.serviceUrl}remove?placeId=${placeId}&key=${this.urlEncodeIfNeeded(key).toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=`
            : `${this.serviceUrl}remove?placeId=${placeId}&key=${this.nameUrlEncodedIfNeeded.toString()}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}`;
    }
    /**
     * @internal
     */
    constructRemoveV2Url(key) {
        return this.isLegacy
            ? `${this.serviceUrl}${this.getDataStoreTypeString()}/remove?key=${this.urlEncodeIfNeeded(key).toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=`
            : `${this.serviceUrl}${this.getDataStoreTypeString()}/remove?key=${this.nameUrlEncodedIfNeeded.toString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&target=${this.urlEncodeIfNeeded(key).toString()}`;
    }
    /**
     * @internal
     */
    createFetchNewKeyRequest(key, request) {
        if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
            request.url = this.constructGetV2Url(key);
            request.owner = this;
            request.method = 'GET';
            return;
        }
        request.url = this.constructGetUrl();
        request.postData = this.constructPostDataForKey(key);
        request.owner = this;
    }
    /**
     * @internal
     */
    static serializeVariant(variant) {
        let hasJsonType = true;
        let result;
        try {
            result = JSON.stringify(variant);
        }
        catch {
            hasJsonType = false;
        }
        return [hasJsonType, result];
    }
    /**
     * @internal
     */
    logLongValue(value) {
        (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Value: %s', value.substring(0, 200));
        if (value.length > 200) {
            const tail = value.substring(value.length - 200);
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Value end: %s', tail);
            (0, FastLogTool_1.FASTLOG1)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Value length: %u', value.length);
        }
    }
    /**
     * @internal
     */
    static deserializeVariant(webValue) {
        if (webValue instanceof Object)
            return [true, webValue];
        let result = '';
        if (webValue && webValue.length === 0)
            return [true, result];
        try {
            result = JSON.parse(webValue);
        }
        catch {
            return [false, result];
        }
        return [true, result];
    }
    /**
     * https://git.mfdlabs.local/petko/rbx-datastores-typescript/issues/142
     * https://roblox.backlog.mfdlabs.local/ui/petko/rbx-datastores-typescript/issues/15
     * @internal
     */
    runTransformFunction(key, transformFunc) {
        return new Promise((resumeFunction, errorFunction) => {
            const request = new HttpRequest_1.HttpRequest();
            this.createFetchNewKeyRequest(key, request);
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request).then((r) => {
                if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                    let result;
                    let data;
                    if (r.status === 204) {
                        data = undefined;
                    }
                    else {
                        // the result is the response, no legacy data key.
                        const [deserializedResult, res] = GlobalDataStore.deserializeVariant(r.data);
                        if (!deserializedResult) {
                            if ((0, FastLogTool_1.DFFlag)('DataStoreNewEndpointsReturnResultIfFailedToDeserialize')) {
                                data = r.data;
                            }
                            else {
                                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                            }
                        }
                        else {
                            data = res;
                        }
                    }
                    (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Running transform function, input: %s', JSON.stringify(data));
                    try {
                        result = transformFunc(data, undefined);
                    }
                    catch (e) {
                        return errorFunction(e);
                    }
                    if (result === undefined || result.size === 0 || result === null) {
                        (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Transform function returned nil, update is cancelled');
                        return errorFunction('Transform function returned nil, update is cancelled');
                    }
                    if (!this.checkValueIsAllowed(result))
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof result));
                    const value = JSON.parse(JSON.stringify(result));
                    if (value.length > (0, FastLogTool_1.DFInt)('DataStoreMaxValueSize'))
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.VALUE_TOO_LARGE));
                    const usn = r.headers['roblox-usn'];
                    const request = new HttpRequest_1.HttpRequest();
                    request.url = this.constructSetIfV2Url(key, usn);
                    request.postData = value;
                    request.owner = this;
                    request.key = key;
                    request.requestType = DataStoreService_1.RequestType.UPDATE_ASYNC;
                    (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] SetIf on key: %s', key);
                    this.logLongValue(JSON.stringify(value));
                    ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                        .then((r2) => {
                        const [success, res] = GlobalDataStore.deserializeVariant(r.data);
                        if (!success)
                            return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                        if (this.callbacks.has(key)) {
                            this.callbacks.get(key)(res);
                        }
                        const usn = res['usn'];
                        if (this.CachedUsns.get(key) !== usn) {
                            this.CachedUsns.set(key, usn);
                        }
                        return resumeFunction(res);
                    })
                        .catch((reason) => {
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
                    });
                    return;
                }
                const [success, res] = GlobalDataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction("Can't parse response");
                let result;
                const data = res['data'];
                if (!Array.isArray(data))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const lastValue = data.length === 0 ? undefined : data[0]['Value'];
                if (lastValue === undefined && data.length > 0)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const [didDeserialize, deserializedValue] = GlobalDataStore.deserializeVariant(lastValue);
                if (!didDeserialize)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Running transform function, input: %s', data.length === 0 ? undefined : deserializedValue.toString());
                try {
                    result = transformFunc(data.length === 0 ? undefined : deserializedValue, undefined);
                }
                catch (e) {
                    return errorFunction(e);
                }
                if (result === undefined || result.size === 0 || result === null) {
                    (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Transform function returned nil, update is cancelled');
                    return errorFunction('Transform function returned nil, update is cancelled');
                }
                // console.log(result);
                if (!this.checkValueIsAllowed(result))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof result));
                const [success2, newValue] = GlobalDataStore.serializeVariant(result);
                if (!success2)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof result));
                if (newValue.length > (0, FastLogTool_1.DFInt)('DataStoreMaxValueSize'))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.VALUE_TOO_LARGE));
                const expectedValue = data.length === 0 ? '' : lastValue;
                const postData = `value=${this.urlEncodeIfNeeded(newValue)}&expectedValue=${this.urlEncodeIfNeeded(expectedValue)}`;
                const postDataFinal = postData.toString();
                const request = new HttpRequest_1.HttpRequest();
                request.url = this.constructSetIfUrl(key, newValue.length, expectedValue.length);
                request.postData = postDataFinal.toString();
                request.owner = this;
                request.key = key;
                request.requestType = DataStoreService_1.RequestType.UPDATE_ASYNC;
                (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] SetIf on key: %s', key);
                this.logLongValue(newValue);
                (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Url encoded:');
                this.logLongValue(request.postData);
                ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                    .then((r2) => {
                    const [success, res] = GlobalDataStore.deserializeVariant(r2.data);
                    if (!success)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                    if (!res['data'])
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                    const final = GlobalDataStore.deserializeVariant(res['data'])[1];
                    if (this.callbacks.has(key)) {
                        this.callbacks.get(key)(final);
                    }
                    resumeFunction(final);
                })
                    .catch((reason) => {
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
                });
            });
        });
    }
    /**
     * @internal
     */
    checkValueIsAllowed(v) {
        const [success] = GlobalDataStore.serializeVariant(v);
        return success;
    }
    /**
     * @internal
     */
    getDataStoreTypeString() {
        return 'standard';
    }
    /**
     * @internal
     */
    urlEncodeIfNeeded(input) {
        return encodeURIComponent(input);
    }
    /**
     * @internal
     */
    urlApiPath() {
        if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints'))
            return 'v1/persistence';
        return 'persistence';
    }
    /**
     * This function returns the latest value of the provided key and a [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) instance.
     * If the key does not exist or if the latest version has been marked as deleted, both return values will be nil.
     *
     * ---
     * WARNING
     * --------
     * [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) does not support v2.0 features such as versioning and metadata,
     * so [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) will always be `nil` for keys in an [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore).
     * [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) will also be `nil` if v2.0 experimental features are not enabled.
     *
     * Keys are cached locally for 4 seconds after the first read.
     * A [GlobalDataStore:GetAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/GetAsync) call within these 4 seconds returns a value from the cache.
     * Modifications to the key by [GlobalDataStore:SetAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/SetAsync) or [GlobalDataStore:UpdateAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/UpdateAsync|GlobalDataStore:UpdateAsync) apply to the cache immediately and restart the 4 second timer.
     *
     * ---
     * NOTICE
     * --------
     * To get a specific version, such as a version before the latest, use [DataStore:GetVersionAsync](https://developer.roblox.com/en-us/api-reference/function/DataStore/GetVersionAsync).
     *
     * ---
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} key The key name for which the value is requested. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @returns {[Variant, DataStoreKeyInfo]} The value of the entry in the data store with the given key and a [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) instance that includes the version number, date and time the version was created, and functions to retrieve [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId) and [metadata](https://developer.roblox.com/en-us/articles/Data-store#metadata).
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async GetAsync(key) {
        return new Promise((resumeFunction, errorFunction) => {
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] GetAsync on key %s`, key);
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            this.createFetchNewKeyRequest(key, request);
            request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteGet(request)
                .then((r) => {
                if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                    if (r.status === 204)
                        return resumeFunction(undefined); // NO data
                    // the result is the response, no legacy data key.
                    const [deserializedResult, result] = GlobalDataStore.deserializeVariant(r.data); // It should be a string "{DATA}"
                    if (!deserializedResult) {
                        if ((0, FastLogTool_1.DFFlag)('DataStoreNewEndpointsReturnResultIfFailedToDeserialize'))
                            return resumeFunction(r.data);
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                    }
                    const usn = r.headers['roblox-usn'];
                    if (this.CachedUsns.get(key) !== usn) {
                        this.CachedUsns.set(key, usn);
                    }
                    return resumeFunction(result);
                }
                const [success, result] = GlobalDataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                const data = result['data'];
                if (!Array.isArray(data))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                const value = data.length > 0 ? data[0]['Value'] : undefined;
                if (value === undefined && data.length > 0)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                if (data.length === 0) {
                    this.CachedKeys.set(key, undefined);
                    return resumeFunction(undefined);
                }
                const [didDeserialize, deserialized] = GlobalDataStore.deserializeVariant(value);
                if (!didDeserialize)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                this.CachedKeys.set(key, deserialized);
                return resumeFunction(deserialized);
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    /**
     *
     * This function sets the latest value, [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId), and metadata for the given key.
     * Values in data stores are versioned,
     * meaning [GlobalDataStore:SetAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/SetAsync) will create a new version every time it is called.
     * Prior versions can be accessed through [DataStore:ListVersionsAsync](https://developer.roblox.com/en-us/api-reference/function/DataStore/ListVersionsAsync)/[DataStore:GetVersionAsync](https://developer.roblox.com/en-us/api-reference/function/DataStore/GetVersionAsync) for up to 30 days at which point they are permanently deleted.
     *
     * ---
     * WARNING
     * --------
     * [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) does not support v2.0 features such as versioning, so calling this method on an [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) key will overwrite the current value and make previous versions inaccessible.
     *
     * ---
     * CRITICAL
     * --------
     * If the previous value of the key is important,
     * use UpdateAsync() instead.
     * Using GetAsync() to retrieve a value and then setting the key with SetAsync() is risky because GetAsync() sometimes returns cached data and other game servers may have modified the key.
     *
     * ---
     * CRITICAL
     * --------
     * Metadata definitions must always be updated with a value, even if there are no changes to the current value; otherwise the current value will be lost.
     *
     * ---
     * ---
     * WARNING
     * -------
     * Any string being stored in a data store must be valid UTF-8.
     * In UTF-8,
     * values greater than 127 are used exclusively for encoding multi-byte codepoints,
     * so a single byte greater than 127 will not be valid UTF-8 and the SetAsync() attempt will fail.
     *
     * ---
     * SET VS. UPDATE
     * ------
     * [GlobalDataStore:SetAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/SetAsync) is best for a quick update of a specific key,
     * and it only counts against the write limit.
     * However, it may cause data inconsistency if two servers attempt to set the same key at the same time.
     * [GlobalDataStore:UpdateAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/UpdateAsync|GlobalDataStore:UpdateAsync) is safer for handling multi-server attempts because it reads the current key value (from whatever server last updated it) before making any changes.
     * However, it's somewhat slower because it reads before it writes, and it also counts against both the read and write limit.
     *
     * ---
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} key Key name for which the value should be set. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @param {Variant} value The value that the data store key will be set to.
     * @param {number[]} userIds Table of [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId), highly recommended to assist with GDPR tracking/removal.
     * @param {DataStoreSetOptions} options (Optional) [DataStoreSetOptions](https://developer.roblox.com/en-us/api-reference/class/DataStoreSetOptions|DataStoreSetOptions) instance that allows for metadata specification on the key.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     * @returns {Variant} The version identifier of the newly created version. It can be used to retrieve key info using `GlobalDataStore/GetVersionAsync|GetVersionAsync()` or to remove it using `GlobalDataStore/RemoveVersionAsync|RemoveVersionAsync()`.
     * @unsafe For thread safety, this property is not safe to read in an unsynchronized thread
     */
    async SetAsync(key, value, userIds = [], options = undefined) {
        return new Promise((resumeFunction, errorFunction) => {
            /*
                If {usn} is not provided at all, the operation is unconditional and the provided value replaces any exiting value of the key. The return status is 200 OK and the result object is a {Roblox.GamePersistence.Api.Models.V1.SetResponse} instance containing the new USN of the key.
                If {usn} is provided and empty, the operation only succeeds if the specified key does not exist. If {usn} is not empty, the operation only succeeds if the current key USN matches the provided USN.
                If the condition is not matched, the response status is 409 conflict and the response body contains the current key value. The current key USN is provided in the Roblox-Usn header. This is exact same response as from a GET operation on this key.
            */
            if (userIds.length > 0)
                return errorFunction('Additional parameter UserIds not allowed');
            if (options)
                return errorFunction('Additional parameter Options not allowed');
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            if (value === undefined)
                return errorFunction("The value can't be nil, null, undefined or void");
            if (!this.checkValueIsAllowed(value))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof value));
            const [success2, v] = GlobalDataStore.serializeVariant(value);
            if (!success2)
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE, typeof value));
            if (v.length > (0, FastLogTool_1.DFInt)('DataStoreMaxValueSize'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.VALUE_TOO_LARGE));
            const request = new HttpRequest_1.HttpRequest();
            if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                request.url = this.constructSetV2Url(key);
                request.owner = this;
                request.key = key;
                request.requestType = DataStoreService_1.RequestType.GET_ASYNC;
                request.additionalHeaders['content-type'] = 'application/octet-stream';
                request.postData = v;
                (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] SetAsync on key: %s`, key);
                this.logLongValue(v);
                (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] JSON encoded:');
                this.logLongValue(request.postData);
            }
            else {
                request.url = this.constructSetUrl(key, v.length);
                request.owner = this;
                request.key = key;
                request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
                request.postData = `value=${this.urlEncodeIfNeeded(v.toString())}`.toString();
                (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], `[FLog::DataStore] SetAsync on key: %s`, key);
                this.logLongValue(v);
                (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Url encoded:');
                this.logLongValue(request.postData);
            }
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                    const [success, res] = GlobalDataStore.deserializeVariant(r.data);
                    if (!success)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                    if (this.callbacks.has(key)) {
                        this.callbacks.get(key)(value);
                    }
                    const usn = res['usn'];
                    if (this.CachedUsns.get(key) !== usn) {
                        this.CachedUsns.set(key, usn);
                    }
                    return resumeFunction(undefined);
                }
                const [success, res] = GlobalDataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                if (!res['data'])
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(value);
                }
                resumeFunction(undefined);
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    /**
     * This function increments the value of a key by the provided amount (both must be integers).
     *
     * ---
     * WARNING
     * --------
     * [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) does not support v2.0 features such as versioning, so calling this method on an [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) key will overwrite the current value and make previous versions inaccessible.
     * ---
     *
     * ---
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} key Key name for which the value should be updated. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @param {number=1} delta 	Amount to increment the current value by.
     * @param {number[]} userIds Table of [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId) to associate with the key.
     * @param {DataStoreSetOptions} options (Optional) [DataStoreIncrementOptions](https://developer.roblox.com/en-us/api-reference/class/DataStoreIncrementOptions) instance that combines multiple additional parameters as custom metadata and allows for future extensibility.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     * @returns {Variant} The updated value of the entry in the data store with the given key.
     * @unsafe For thread safety, this property is not safe to read in an unsynchronized thread.
     */
    async IncrementAsync(key, delta = 1, userIds = [], options = undefined) {
        return new Promise((resumeFunction, errorFunction) => {
            if (userIds.length > 0)
                return errorFunction('Additional parameter UserIds not allowed');
            if (options)
                return errorFunction('Additional parameter Options not allowed');
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                request.url = this.constructIncrementV2Url(key, delta);
            }
            else {
                request.url = this.constructIncrementUrl(key, delta);
            }
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.INCREMENT_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((r) => {
                if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                    const [success, result] = GlobalDataStore.deserializeVariant(r.data);
                    if (!success)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                    if (!result['value'])
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                    const value = parseFloat(result['value']) || 0;
                    const usn = result['usn'];
                    if (this.CachedUsns.get(key) !== usn) {
                        this.CachedUsns.set(key, usn);
                    }
                    if (this.callbacks.has(key)) {
                        this.callbacks.get(key)(value);
                    }
                    return resumeFunction(value);
                }
                const [success, res] = GlobalDataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                if (!res['data'])
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE));
                if (this.callbacks.has(key)) {
                    this.callbacks.get(key)(parseFloat(res['data']) || 0);
                }
                resumeFunction(parseFloat(res['data']) || 0);
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    /**
     * This function retrieves the value and metadata of a key from the data store and updates it with a new value determined by the callback function specified through the second parameter.
     * If the update succeeds, a new version of the value will be created and prior versions will remain accessible through [DataStore:ListVersionsAsync](https://developer.roblox.com/en-us/api-reference/function/DataStore/ListVersionsAsync) and [DataStore:GetVersionAsync](https://developer.roblox.com/en-us/api-reference/function/DataStore/GetVersionAsync).
     *
     * ---
     * WARNING
     * --------
     * [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) does not support v2.0 features such as versioning, so calling this method on an [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) key will overwrite the current value and make previous versions inaccessible.
     *
     * ---
     *
     * INFO
     * -----
     * In cases where another game server updated the key in the short timespan between retrieving the key's current value and setting the key's value,
     * [GlobalDataStore:UpdateAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/UpdateAsync|GlobalDataStore:UpdateAsync) will call the function again to ensure that no data is overwritten.
     * The function will be called as many times as needed until the data is saved.
     *
     * ---
     * CRITICAL
     * ---------
     * The function you define as the second parameter of UpdateAsync() cannot yield,
     * so do not include calls like setTimeout().
     *
     * ---
     * NOTICE
     * -------
     * Any string being stored in a data store must be valid UTF-8.
     * In UTF-8,
     * values greater than 127 are used exclusively for encoding multi-byte codepoints,
     * so a single byte greater than 127 will not be valid UTF-8 and the SetAsync() attempt will fail.
     *
     * ---
     * SET VS. UPDATE
     * ------
     * [GlobalDataStore:SetAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/SetAsync) is best for a quick update of a specific key,
     * and it only counts against the write limit.
     * However, it may cause data inconsistency if two servers attempt to set the same key at the same time.
     * [GlobalDataStore:UpdateAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/UpdateAsync|GlobalDataStore:UpdateAsync) is safer for handling multi-server attempts because it reads the current key value (from whatever server last updated it) before making any changes.
     * However, it's somewhat slower because it reads before it writes, and it also counts against both the read and write limit.
     *
     * ---
     * CALLBACK FUNCTION
     * -------
     * The callback function accepts two arguments:
     * - Current value of the key prior to the update.
     * - [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) instance that contains the latest version information (this argument can be ignored if metadata is not being used).
     *
     * In turn, the callback function returns up to three values:
     * - The new value to set for the key.
     * - An array of [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId) to associate with the key. [DataStoreKeyInfo:GetUserIds](https://developer.roblox.com/en-us/api-reference/function/DataStoreKeyInfo/GetUserIds) should be returned unless the existing IDs are being changed; otherwise all existing IDs will be cleared.
     * - A Map containing metadata to associate with the key. [DataStoreKeyInfo:GetMetadata](https://developer.roblox.com/en-us/api-reference/function/DataStoreKeyInfo/GetMetadata) should be returned unless the existing metadata is being changed; otherwise all existing metadata will be cleared.
     *
     * ---
     * CRITICAL
     * -------
     * The callback function cannot yield, so do not include calls like wait().
     *
     * ---
     * SEE ALSO
     * --------
     * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
     * ---
     *
     * @param {string} key Key name for which the value should be updated. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @param {Function} transformFunction Transform function that takes the current value and [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) as parameters and returns the new value along with optional [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId) and metadata.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async UpdateAsync(key, transformFunction) {
        return new Promise(async (resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Updating key %s', key);
            this.runTransformFunction(key, transformFunction)
                .then(resumeFunction)
                .catch(errorFunction);
        });
    }
    /**
     * This function marks the specified key as deleted by creating a new “tombstone” version of the key.
     * Prior to this, it returns the latest version prior to the remove call.
     * After a key is removed via this function, [GlobalDataStore:GetAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/GetAsync) calls for the key will return nil.
     * Older versions of the key remain accessible through `GlobalDataStore/ListVersionsAsync` and `GlobalDataStore/GetVersionAsync`, assuming they have not expired.
     *
     * ---
     * WARNING
     * --------
     * [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) does not support versioning, so calling [GlobalDataStore:RemoveAsync](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/RemoveAsync) on an [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore) key will permanently delete it.
     *
     * Removed objects will be deleted permanently after 30 days.
     *
     * ---
     *
     * @param {string} key Key name to be removed. If [DataStoreOptions.AllScopes](https://developer.roblox.com/en-us/api-reference/property/DataStoreOptions/AllScopes) was set to true when accessing the data store through [DataStoreService:GetDataStore](https://developer.roblox.com/en-us/api-reference/function/DataStoreService/GetDataStore), this key name must be prepended with the original scope as in “scope/key”.
     * @returns {Variant} The value of the data store prior to deletion and a [DataStoreKeyInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreKeyInfo) instance that includes the version number, date and time the version was created, and functions to retrieve [UserIds](https://developer.roblox.com/en-us/api-reference/property/Player/UserId) and [metadata](https://developer.roblox.com/en-us/articles/Data-store#metadata).
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async RemoveAsync(key) {
        return new Promise((resumeFunction, errorFunction) => {
            const [success, message] = InputHelper_1.InputHelper.CheckKey(key);
            if (!success)
                return errorFunction(message);
            const request = new HttpRequest_1.HttpRequest();
            if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                request.url = this.constructRemoveV2Url(key);
            }
            else {
                request.url = this.constructRemoveUrl(key);
            }
            request.owner = this;
            request.key = key;
            request.requestType = DataStoreService_1.RequestType.SET_ASYNC;
            ExecutionHelper_1.ExectionHelper.ExecuteSet(request)
                .then((value) => {
                if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                    const [success, res] = GlobalDataStore.deserializeVariant(value.data);
                    if (!success)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                    const usn = res['usn'];
                    if (this.CachedUsns.get(key) !== usn) {
                        this.CachedUsns.set(key, usn);
                    }
                    return resumeFunction(res);
                }
                const [success, res] = GlobalDataStore.deserializeVariant(value.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                resumeFunction(GlobalDataStore.deserializeVariant(res['data'])[1]);
            })
                .catch((e) => {
                return errorFunction(e);
            });
        });
    }
    /**
     * This function sets **callback** as the function to be run any time the value associated with the [data store's](https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore) key changes.
     * Once every minute, OnUpdate polls for changes by other servers.
     * Changes made on the same server will run the function immediately. In other words,
     * functions like [IncrementAsync()](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/IncrementAsync), [SetAsync()](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/SetAsync), and [UpdateAsync()](https://developer.roblox.com/en-us/api-reference/function/GlobalDataStore/UpdateAsync) change the key’s value in the data store and will cause the function to run.
     * See the [Data Stores](https://developer.roblox.com/en-us/articles/Data-store) article for an in-depth guide on data structure, management, error handling, etc.
     *
     * ---
     * CRITICAL
     * -------
     * It's recommended that you **disconnect** the connection when the subscription to the key is no longer needed.
     *
     * ---
     *
     * @param {string} key The key identifying the entry being retrieved from the data store
     * @param {Function} callback The function to be executed any time the value associated with **key** is changed
     * @returns {RBXScriptConnection} The connection to the key being tracked for updates
     * @deprecated This function has been deprecated and should not be used in new work. You can use the [Cross Server Messaging Service](https://www.npmjs.com/package/@mfd/rbxmessagingservice) to publish and subscribe to topics to receive near real-time updates, completely replacing the need for this function.
     */
    OnUpdate(key, callback) {
        (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['DataStore'], '[FLog::DataStore] Legacy on update callback set for the key %s', key);
        this.callbacks.set(key, callback);
        // const interval = setInterval(async () => {
        // 	const v = await this.GetAsync(key);
        // 	if (v !== this.CachedKeys.get(key)) callback(await this.GetAsync(key));
        // }, 60000);
        const event = new events_1.default.EventEmitter();
        event.on('close', () => {
            this.callbacks.delete(key);
            // interval.unref();
        });
        return new RBXScriptConnection_1.RBXScriptConnection(event);
    }
}
exports.GlobalDataStore = GlobalDataStore;
