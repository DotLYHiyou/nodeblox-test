"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderedDataStore = void 0;
const GlobalDataStore_1 = require("./GlobalDataStore");
const DataStorePages_1 = require("./DataStorePages");
const Globals_1 = require("../Util/Globals");
const FastLogTool_1 = require("../Tools/FastLogTool");
const ErrorHelper_1 = require("../Helpers/ErrorHelper");
const ErrorType_1 = require("../Enumeration/ErrorType");
(0, FastLogTool_1.DYNAMIC_FASTINTVARIABLE)('DataStoreMaxPageSize', 100);
(0, FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE)('DataStoreUseNewEndpoints', true);
/**
 * A **OrderedDataStore** is essentially a [GlobalDataStore](https://developer.roblox.com/en-us/api-reference/class/GlobalDataStore) with the exception that stored values must be **positive integers**.
 * It exposes a method [GetSortedAsync()](https://developer.roblox.com/en-us/api-reference/function/OrderedDataStore/GetSortedAsync) which allows inspection of the entries in sorted order using a [DataStorePages](https://developer.roblox.com/en-us/api-reference/class/DataStorePages) object.
 * See the [Data Stores](https://developer.roblox.com/en-us/articles/Data-store) article for an in-depth guide on data structure, management, error handling, etc.
 */
class OrderedDataStore extends GlobalDataStore_1.GlobalDataStore {
    /**
     * @internal
     */
    constructor(name, scope) {
        super(name, scope, false, false);
    }
    /**
     * @internal
     */
    constructGetSortedUrl(isAscending, pagesize, minValue, maxValue) {
        const placeId = Globals_1.Globals.PlaceID;
        let url = `${this.serviceUrl}getSortedValues?placeId=${placeId}&type=${this.getDataStoreTypeString()}&scope=${this.scopeUrlEncodedIfNeeded.toString()}&key=${this.nameUrlEncodedIfNeeded.toString()}&pageSize=${pagesize}&ascending=${isAscending ? 'True' : 'False'}`;
        if (minValue && typeof minValue === 'number')
            url += '&inclusiveMinValue=' + Math.floor(minValue).toString();
        if (maxValue && typeof maxValue === 'number')
            url += '&inclusiveMaxValue=' + Math.floor(maxValue).toString();
        return url.toString();
    }
    /**
     * @internal
     */
    constructGetSortedV2Url(isAscending, pagesize, minValue, maxValue) {
        let url = `${this.serviceUrl}${this.getDataStoreTypeString()}/list?&scope=${this.scopeUrlEncodedIfNeeded.toString()}&key=${this.nameUrlEncodedIfNeeded.toString()}&pageSize=${pagesize}&direction=${isAscending ? 'asc' : 'desc'}`;
        if (minValue && typeof minValue === 'number')
            url += '&minValue=' + Math.floor(minValue).toString();
        if (maxValue && typeof maxValue === 'number')
            url += '&maxValue=' + Math.floor(maxValue).toString();
        return url.toString();
    }
    /**
     * @internal
     */
    checkValueIsAllowed(v) {
        return typeof v === 'number';
    }
    /**
     * @internal
     */
    getDataStoreTypeString() {
        return 'sorted';
    }
    /**
     * Returns a [DataStorePages](https://developer.roblox.com/en-us/api-reference/class/DataStorePages) object.
     * The sort order is determined by **ascending**, the length of each page by **pageSize**, and **minValue**\/**maxValue** are optional parameters which filter the results.
     *
     * If this function throws an error, the [error message](https://developer.roblox.com/en-us/articles/Datastore-Errors) will describe the problem.
     * @param {boolean} ascending A boolean indicating whether the returned data pages are in ascending order.
     * @param {number} pagesize The length of each page.
     * @param {number?} minValue Optional parameter. If set, data pages with a value less than than **minValue** will be excluded.
     * @param {number?} maxValue Optional parameter. If set, data pages with a value greater than **maxValue** will be excluded.
     * @returns {DataStorePages} A sorted [DataStorePages](https://developer.roblox.com/en-us/api-reference/class/DataStorePages) object based on the provided arguments.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async GetSortedAsync(ascending, pagesize, minValue, maxValue) {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (!(minValue === undefined) && !this.checkValueIsAllowed(minValue))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MAX_VAL_AND_MIN_VAL_NOT_INTEGERS));
            if (!(maxValue === undefined) && !this.checkValueIsAllowed(maxValue))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MAX_VAL_AND_MIN_VAL_NOT_INTEGERS));
            if (pagesize < 0)
                return errorFunction('PageSize has to be more or equal to zero');
            if (pagesize > (0, FastLogTool_1.DFInt)('DataStoreMaxPageSize'))
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.PAGE_SIZE_MUST_BE_IN_RANGE));
            const pagination = new DataStorePages_1.DataStorePages(this, (0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')
                ? this.constructGetSortedV2Url(ascending, pagesize, minValue, maxValue)
                : this.constructGetSortedUrl(ascending, pagesize, minValue, maxValue));
            await pagination
                .AdvanceToNextPageAsync()
                .then(() => resumeFunction(pagination))
                .catch(errorFunction);
        });
    }
}
exports.OrderedDataStore = OrderedDataStore;
