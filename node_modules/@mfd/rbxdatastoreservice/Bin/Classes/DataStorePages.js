"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStorePages = void 0;
const OrderedDataStore_1 = require("./OrderedDataStore");
const HttpRequest_1 = require("./HttpRequest");
const DataStoreService_1 = require("./Services/DataStoreService");
const Pages_1 = require("./Pages");
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
const FastLogTool_1 = require("../Tools/FastLogTool");
const ErrorHelper_1 = require("../Helpers/ErrorHelper");
const ErrorType_1 = require("../Enumeration/ErrorType");
const KeyValueMapping_1 = require("../Util/KeyValueMapping");
(0, FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE)('DataStoreUseNewEndpoints', true);
/**
 * A special type of [Pages](https://developer.roblox.com/en-us/api-reference/class/Pages) object whose pages contain key/value pairs from an [OrderedDataStore](https://developer.roblox.com/en-us/api-reference/class/OrderedDataStore).
 * For this object, [GetCurrentPage()](https://developer.roblox.com/en-us/api-reference/function/Pages/GetCurrentPage) returns an array of tables, each containing keys named **key** and **value**; these reflect the key/value pair data.
 */
class DataStorePages extends Pages_1.Pages {
    /**
     * @internal
     */
    constructor(ds, requestUrl) {
        super();
        this.ds = ds;
        this.requestUrl = requestUrl;
        this.exclusiveStartKey = '';
    }
    GetCurrentPage() {
        return this.currentPage;
    }
    /**
     * @internal
     */
    async FetchNextChunk() {
        return new Promise((resumeFunction, errorFunction) => {
            const request = new HttpRequest_1.HttpRequest();
            const ods = this.ds;
            if (!ods) {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.ORDERERD_DATATORE_DELETED));
            }
            request.url =
                this.exclusiveStartKey.length === 0
                    ? this.requestUrl
                    : `${this.requestUrl.toString()}&exclusiveStartKey=${this.exclusiveStartKey.toString()}`;
            request.requestType = DataStoreService_1.RequestType.GET_SORTED_ASYNC_PAGE;
            if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints'))
                request.method = 'GET';
            request.owner = ods;
            ExecutionHelper_1.ExectionHelper.ExecuteGetSorted(request)
                .then((r) => {
                const [success, result] = OrderedDataStore_1.OrderedDataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                let entries;
                if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                    entries = result['entries'];
                }
                else {
                    entries = result['data']['Entries'];
                }
                if (!Array.isArray(entries))
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_ORDERED_DATASTORE_RESPONSE));
                const newValue = [];
                for (let i = 0; i < entries.length; i++) {
                    const valueAsStr = KeyValueMapping_1.KeyValueMapping.FetchKeyFromObjectCaseInsensitive(entries[i], 'Value');
                    if (valueAsStr === undefined)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_ORDERED_DATASTORE_RESPONSE));
                    const [didDeserialize, value] = OrderedDataStore_1.OrderedDataStore.deserializeVariant(valueAsStr);
                    if (!didDeserialize)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                    const target = KeyValueMapping_1.KeyValueMapping.FetchKeyFromObjectCaseInsensitive(entries[i], 'Target');
                    if (target === undefined)
                        return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.MALFORMED_ORDERED_DATASTORE_RESPONSE));
                    newValue.push({
                        Value: value,
                        Key: target,
                    });
                }
                this.currentPage = newValue;
                if ((0, FastLogTool_1.DFFlag)('DataStoreUseNewEndpoints')) {
                    this.exclusiveStartKey = result['lastEvaluatedKey'] || '';
                }
                else {
                    this.exclusiveStartKey = result['data']['ExclusiveStartKey'] || '';
                }
                return resumeFunction();
            })
                .catch((reason) => {
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(reason));
            });
        });
    }
    /**
     * Iterates to the next page in the pages object,
     * if possible.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async AdvanceToNextPageAsync() {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (this.finished) {
                console.error('No pages to advance to');
                return resumeFunction();
            }
            await this.FetchNextChunk()
                .then(() => resumeFunction())
                .catch((ex) => errorFunction(ex));
        });
    }
}
exports.DataStorePages = DataStorePages;
