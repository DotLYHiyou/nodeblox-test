"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientSettings = exports.Group = void 0;
const fs_1 = __importDefault(require("fs"));
/**
 * @internal
 */
var Group;
(function (Group) {
    Group[Group["FVariable"] = 0] = "FVariable";
    Group[Group["FLog"] = 1] = "FLog";
    Group[Group["DFLog"] = 2] = "DFLog";
    Group[Group["SFLog"] = 3] = "SFLog";
    Group[Group["FFlag"] = 4] = "FFlag";
    Group[Group["DFFlag"] = 5] = "DFFlag";
    Group[Group["SFFlag"] = 6] = "SFFlag";
    Group[Group["FInt"] = 7] = "FInt";
    Group[Group["DFInt"] = 8] = "DFInt";
    Group[Group["SFInt"] = 9] = "SFInt";
    Group[Group["FString"] = 10] = "FString";
    Group[Group["DFString"] = 11] = "DFString";
    Group[Group["SFString"] = 12] = "SFString";
    Group[Group["FPFilter"] = 13] = "FPFilter";
    Group[Group["FSettings"] = 14] = "FSettings";
    Group[Group["All"] = 15] = "All";
})(Group = exports.Group || (exports.Group = {}));
/**
 * @internal
 */
class ClientSettings {
    static GetSettings(settingsType, settingsGroup = 'Client') {
        try {
            const settings = JSON.parse(fs_1.default.readFileSync(__dirname + `/../../settings${process.env.DEV_TEST !== undefined ? '.dev.' : '.'}json`, 'ascii'));
            if (settingsType || settingsType === 0 || settingsType === Group.FFlag) {
                switch (settingsType) {
                    case Group.FVariable:
                        return settings[settingsGroup]['FVariable'];
                    case Group.FLog:
                        return settings[settingsGroup]['FLog'];
                    case Group.DFLog:
                        return settings[settingsGroup]['DFLog'];
                    case Group.SFLog:
                        return settings[settingsGroup]['SFLog'];
                    case Group.FFlag:
                        return settings[settingsGroup]['FFlag'];
                    case Group.DFFlag:
                        return settings[settingsGroup]['DFFlag'];
                    case Group.SFFlag:
                        return settings[settingsGroup]['SFFlag'];
                    case Group.FInt:
                        return settings[settingsGroup]['FInt'];
                    case Group.DFInt:
                        return settings[settingsGroup]['DFInt'];
                    case Group.SFInt:
                        return settings[settingsGroup]['SFInt'];
                    case Group.FString:
                        return settings[settingsGroup]['FString'];
                    case Group.DFString:
                        return settings[settingsGroup]['DFString'];
                    case Group.SFString:
                        return settings[settingsGroup]['SFString'];
                    case Group.FPFilter:
                        return settings[settingsGroup]['FPFilter'];
                    case Group.FSettings:
                        return settings['FSettings'];
                    case Group.All:
                        return settings[settingsGroup];
                    default:
                        return new Error(`Settings Group '${settingsType}' doesn't exist.`);
                }
            }
        }
        catch {
            return null;
        }
    }
    static GetFVariables(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.FVariable, ctx);
    }
    static GetFLogs(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.FLog, ctx);
    }
    static GetDFLogs(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.DFLog, ctx);
    }
    static GetSFLogs(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.SFLog, ctx);
    }
    static GetFFlags(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.FFlag, ctx);
    }
    static GetDFFlags(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.DFFlag, ctx);
    }
    static GetSFFlags(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.SFFlag, ctx);
    }
    static GetFInts(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.FInt, ctx);
    }
    static GetDFInts(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.DFInt, ctx);
    }
    static GetSFInts(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.SFInt, ctx);
    }
    static GetFStrings(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.FString, ctx);
    }
    static GetDFStrings(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.DFString, ctx);
    }
    static GetSFStrings(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.SFString, ctx);
    }
    static GetFPFilters(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.FPFilter, ctx);
    }
    static GetFSettings(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.FSettings, ctx);
    }
    static GetAllSettings(ctx = 'Client') {
        return ClientSettings.GetSettings(Group.All, ctx);
    }
    static GetPlaceIDInPlaceFilter(key, placeId, ctx = 'Client') {
        const FPFilter = ClientSettings.GetFPFilters(ctx);
        // This should never go through unless files.api.sitetest4.robloxlabs.com/ClientSettingsFormatted dies.
        if (FPFilter === undefined)
            return false;
        const keyFilter = FPFilter[key];
        if (keyFilter === undefined)
            return false;
        let isInFilter = false;
        keyFilter['PlaceIds'].forEach((id) => {
            if (id === placeId)
                isInFilter = true;
        });
        return isInFilter;
    }
}
exports.ClientSettings = ClientSettings;
