"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorHelper = void 0;
const ErrorType_1 = require("../Enumeration/ErrorType");
const FastLogTool_1 = require("../Tools/FastLogTool");
const util_1 = require("util");
const AnalyticsHelper_1 = require("./AnalyticsHelper");
(0, FastLogTool_1.DYNAMIC_FASTINT)('DataStoreKeyLengthLimit');
(0, FastLogTool_1.DYNAMIC_FASTINT)('DataStoreMaxMetadataSize');
(0, FastLogTool_1.DYNAMIC_FASTINT)('DataStoreMaxUserIdsLimit');
/**
 * @internal
 */
class ErrorHelper {
    static GetErrorMessage(type, arg = undefined) {
        switch (type) {
            case ErrorType_1.ErrorType.NO_EMPTY_KEYNAME:
                return "101: Key name can't be empty.";
            case ErrorType_1.ErrorType.KEYNAME_TOO_LARGE:
                return `102: Key name exceeds the ${(0, FastLogTool_1.DFInt)('DataStoreKeyLengthLimit')} character limit.`;
            case ErrorType_1.ErrorType.DATA_NOT_ALLOWED_IN_DATASTORE:
                return (0, util_1.format)('103: %s is not allowed in DataStore.', arg);
            case ErrorType_1.ErrorType.CANNOT_STORE_DATA_IN_DATASTORE:
                return (0, util_1.format)('104: Cannot store %s in DataStore', arg);
            case ErrorType_1.ErrorType.VALUE_TOO_LARGE:
                return '105: Serialized value converted byte size exeeds max size 64*1024 bytes.';
            case ErrorType_1.ErrorType.MAX_VAL_AND_MIN_VAL_NOT_INTEGERS:
                return '106: MaxValue and MinValue must be integers.';
            case ErrorType_1.ErrorType.PAGE_SIZE_MUST_BE_IN_RANGE:
                return '106: PageSize must be within predefined range.';
            case ErrorType_1.ErrorType.NO_API_ACCESS_ALLOWED:
                return `403: Cannot write to DataStore from Studio if API access is not enabled.`;
            case ErrorType_1.ErrorType.ORDERERD_DATATORE_DELETED:
                return '404: OrderedDataStore does not exists.';
            case ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE:
                AnalyticsHelper_1.Analytics.EphemeralCounter.reportCounter('DataStoresCorruptedResponses', 1);
                AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('DataStores', 'CorruptedResponses', '', 1);
                return "501: Can't parse response, data may be corrupted.";
            case ErrorType_1.ErrorType.API_SERVICES_REJECTED:
                return (0, util_1.format)('502: API Services rejected request with error. %s', arg);
            case ErrorType_1.ErrorType.KEY_NOT_FOUND:
                return '503: DataStore Request successful, but key not found.';
            case ErrorType_1.ErrorType.MALFORMED_DATASTORE_RESPONSE:
                AnalyticsHelper_1.Analytics.EphemeralCounter.reportCounter('DataStoresMalformedResponses', 1);
                AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('DataStores', 'MalformedResponses', '', 1);
                return '504: DataStore Request successful, but the response was not formatted correctly.';
            case ErrorType_1.ErrorType.MALFORMED_ORDERED_DATASTORE_RESPONSE:
                AnalyticsHelper_1.Analytics.EphemeralCounter.reportCounter('DataStoresMalformedResponses', 1);
                AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('DataStores', 'MalformedResponses', '', 1);
                return '505: OrderedDataStore Request successful, but the response was not formatted correctly.';
            case ErrorType_1.ErrorType.METADATA_TOO_LARGE:
                return `Metadata attribute size exceeds ${(0, FastLogTool_1.DFInt)('DataStoreMaxMetadataSize')} bytes limit.`;
            case ErrorType_1.ErrorType.USERID_LIMIT_TOO_LARGE:
                return `UserID size exceeds limit of ${(0, FastLogTool_1.DFInt)('DataStoreMaxUserIdsLimit')}.`;
            case ErrorType_1.ErrorType.USERID_ATTRIBUTE_INVALID:
                return `Attribute userId format invalid.`;
            case ErrorType_1.ErrorType.METATADA_ATTRIBUTE_INVALID:
                return 'Attribute metadata format is invalid.';
        }
    }
    static GetErrorResponseAndReturnMessage(error) {
        AnalyticsHelper_1.Analytics.EphemeralCounter.reportCounter('DataStoreRequestsThatFailed_DataStores', 1);
        AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('DataStores', 'FailedRequests', error !== undefined ? error.toString() : 'unknown', 0);
        if (error.response !== undefined) {
            const response = error.response;
            let data = response.data;
            if (!(data instanceof Object))
                data = JSON.parse(data);
            if (data['error'] !== undefined)
                return ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.API_SERVICES_REJECTED, `Reason: ${data.error}`);
            const errors = data['errors'];
            if (Array.isArray(errors) && errors.length > 0) {
                return ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.API_SERVICES_REJECTED, `Error code: ${errors[0].code} Reason: ${errors[0].message}`);
            }
        }
        return ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.API_SERVICES_REJECTED, `Reason: ${error.message}`);
    }
}
exports.ErrorHelper = ErrorHelper;
