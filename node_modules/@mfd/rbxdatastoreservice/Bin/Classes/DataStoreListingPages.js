"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreListingPages = void 0;
const DataStoreService_1 = require("./Services/DataStoreService");
const HttpRequest_1 = require("./HttpRequest");
const Pages_1 = require("./Pages");
const ExecutionHelper_1 = require("../Helpers/ExecutionHelper");
const DataStoreInfo_1 = require("./DataStoreInfo");
const DataStore_1 = require("./DataStore");
/**
 * A special type of [Pages](https://developer.roblox.com/en-us/api-reference/class/Pages) object whose pages contain [DataStoreInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreInfo) instances.
 * [Pages:GetCurrentPage](https://developer.roblox.com/en-us/api-reference/function/Pages/GetCurrentPage) can be used to retrieve an array of the [DataStoreInfo](https://developer.roblox.com/en-us/api-reference/class/DataStoreInfo) instances.
 *
 * ---
 * SEE ALSO
 * --------
 * - [Data Stores](https://developer.roblox.com/en-us/articles/Data-store), an in-depth guide on data structure, management, error handling, etc.
 *
 * ---
 */
class DataStoreListingPages extends Pages_1.Pages {
    /**
     * @internal
     */
    constructor(dss, requestUrl) {
        super();
        this.dss = dss;
        this.requestUrl = requestUrl;
        this.exclusiveStartKey = '';
    }
    GetCurrentPage() {
        return this.currentPage;
    }
    /**
     * @internal
     */
    async FetchNextChunk() {
        return new Promise((resumeFunction, errorFunction) => {
            const request = new HttpRequest_1.HttpRequest();
            const dss = this.dss;
            if (!dss) {
                return errorFunction('DataStoreService no longer exists');
            }
            request.url =
                this.exclusiveStartKey.length === 0
                    ? this.requestUrl
                    : `${this.requestUrl.toString()}&exclusiveStartKey=${this.exclusiveStartKey.toString()}`;
            request.requestType = DataStoreService_1.RequestType.GET_SORTED_ASYNC_PAGE;
            request.method = 'GET';
            ExecutionHelper_1.ExectionHelper.ExecuteGetSorted(request)
                .then((r) => {
                const [success, result] = DataStore_1.DataStore.deserializeVariant(r.data);
                if (!success)
                    return errorFunction("Can't parse response");
                const deserialized = result['datastores'].length !== 0 ? result['datastores'] : [];
                const newValue = [];
                for (let i = 0; i < deserialized.length; i++) {
                    newValue.push(new DataStoreInfo_1.DataStoreInfo(new Date(deserialized[i]['createdTime']).getTime(), new Date(deserialized[i]['updatedTime']).getTime(), deserialized[i]['name']));
                }
                this.exclusiveStartKey = result['lastReturnedKey'] || '';
                this.currentPage = newValue;
                return resumeFunction();
            })
                .catch((reason) => {
                return errorFunction(reason);
            });
        });
    }
    /**
     * Iterates to the next page in the pages object,
     * if possible.
     * @yields This is a yielding function. When called, it will pause the JavaScript thread that called the function until a result is ready to be returned, without interrupting other scripts.
     */
    async AdvanceToNextPageAsync() {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (this.finished) {
                console.error('No pages to advance to');
                return resumeFunction();
            }
            await this.FetchNextChunk()
                .then(() => resumeFunction())
                .catch((ex) => errorFunction(ex));
        });
    }
}
exports.DataStoreListingPages = DataStoreListingPages;
