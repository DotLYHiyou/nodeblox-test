"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthenticationHelper = void 0;
const Constants_1 = require("../Util/Constants");
const axios_1 = __importDefault(require("axios"));
const FastLogTool_1 = require("../Tools/FastLogTool");
const UniversesHelper_1 = require("./UniversesHelper");
const UrlTool_1 = require("../Tools/UrlTool");
const Globals_1 = require("../Util/Globals");
const https_1 = require("https");
const AnalyticsHelper_1 = require("./AnalyticsHelper");
const ErrorHelper_1 = require("./ErrorHelper");
const ErrorType_1 = require("../Enumeration/ErrorType");
(0, FastLogTool_1.LOGVARIABLE)('Auth', 0);
(0, FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE)('WeCareAboutTheWarning', true);
(0, FastLogTool_1.FASTFLAG)('Debug');
(0, FastLogTool_1.LOGVARIABLE)('Auth', 0);
(0, FastLogTool_1.DYNAMIC_FASTFLAGVARIABLE)('WeCareAboutTheWarning', true);
(0, FastLogTool_1.FASTFLAG)('Debug');
class AuthenticationHelper {
    /**
     * @internal
     */
    static GetSharedRequestConfiguration(url, cookie, placeID) {
        return {
            url: url,
            method: 'GET',
            headers: {
                ...Globals_1.Globals.GlobalHeaders(),
                Cookie: '.ROBLOSECURITY=' + cookie,
                'Roblox-Place-Id': placeID.toString(),
            },
            httpsAgent: AuthenticationHelper._sharedHttpsAgent,
        };
    }
    /**
     * @internal
     */
    static CheckCookieAndPlaceIdInternalAsync(cookie, placeID) {
        return new Promise(async (resumeFunction, errorFunction) => {
            if (!cookie) {
                (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] The cookie was null or was not a string, aborting.');
                return errorFunction('Cookie cannot be null or undefined.');
            }
            if (typeof cookie === 'string' && cookie.length === 0) {
                (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] The cookie was empty or was not a string, aborting.');
                return errorFunction("Cookie name can't be empty");
            }
            if (placeID < 1) {
                (0, FastLogTool_1.FASTLOG1)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] The placeID was %i when it was expected to be >1', placeID);
                return errorFunction('The placeID is required to at least be >1');
            }
            if (!cookie.match(Constants_1.Constants.CookieWarningCapture) && (0, FastLogTool_1.DFFlag)('WeCareAboutTheWarning')) {
                (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] The cookie was invalid because it did not contain the warning text.');
                return errorFunction("Cookie isn't valid, it requires the warning text to be present.");
            }
            const authenticatedUserUrl = UrlTool_1.BaseURL.ConstructServicePathFromSubDomain('users', 'v1/users/authenticated', null, true, false, true);
            try {
                const authenticatedUser = ((await axios_1.default.request(AuthenticationHelper.GetSharedRequestConfiguration(authenticatedUserUrl, cookie, placeID))).data);
                (0, FastLogTool_1.FASTLOG3)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our cookie check succeeded for user %s - %s (%d), try validate the place ownership and call the resumeFunction()', authenticatedUser.name, authenticatedUser.displayName, authenticatedUser.id);
                Globals_1.Globals.UserID = authenticatedUser.id;
                Globals_1.Globals.Cookie = cookie;
                const universeId = await UniversesHelper_1.UniversesHelper.GetUniverseIDFromPlaceID(placeID);
                const universePermissionsUrl = UrlTool_1.BaseURL.ConstructServicePathFromSubDomain('develop', 'v1/universes/multiget/permissions', { ids: [universeId] }, true, false, true);
                const universePermissions = ((await axios_1.default.request(AuthenticationHelper.GetSharedRequestConfiguration(universePermissionsUrl, cookie, placeID))).data);
                if (universePermissions.data !== null && universePermissions.data.length === 0) {
                    await AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('Authentication', 'EmptyUniversePermissionsResponse', `User '${Globals_1.Globals.UserID.toString()}' for place '${placeID}'`, 0);
                    (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['Auth'], "[FLog::Auth] Our Place check failed because the response's data had an invalid length, call the errorFunction().");
                    return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorMessage(ErrorType_1.ErrorType.CANNOT_PARSE_RESPONSE));
                }
                const noAccess = !universePermissions.data[0].canCloudEdit && !universePermissions.data[0].canManage;
                if (noAccess) {
                    await AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('Authentication', 'UserHadNoPermissions', `User '${Globals_1.Globals.UserID.toString()}' for place '${placeID}'`, 0);
                    (0, FastLogTool_1.FASTLOG)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our Place check failed because the user does not have the valid credentials to manage this place, call the errorFunction().');
                    return errorFunction(`You do not have valid permission to manage the place ${placeID}`);
                }
                await AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('Authentication', 'PermissionsCheckSuccess', `User '${Globals_1.Globals.UserID.toString()}' for place '${placeID}'`, 0);
                (0, FastLogTool_1.FASTLOG2)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our Place check succeeded for %d (%d), call the resumeFunctiom()', placeID, universeId);
                return resumeFunction();
            }
            catch (ex) {
                await AnalyticsHelper_1.Analytics.GoogleAnalytics.trackEvent('Authentication', 'AuthenticationFailure', ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(ex), 0);
                (0, FastLogTool_1.FASTLOGS)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Our authentication check failed because %s, most likely due to a credential mis-match or a permissions mis-match, call the errorFunction()', ex.message);
                return errorFunction(ErrorHelper_1.ErrorHelper.GetErrorResponseAndReturnMessage(ex));
            }
        });
    }
    /**
     * Initializes the global cookie and place id, and tries to validate:
     * 1. The validity of the cookie.
     * 2. The ownership of the user to the place.
     * @param {string} cookie The cookie to use, must include the warning text.
     * @param {number} placeID The place ID to use, the user that is dependent on the cookie must have edit permissions for this place.
     */
    static async InitAuthenticatedUser(cookie, placeID) {
        return new Promise((resumeFunction, errorFunction) => {
            (0, FastLogTool_1.FASTLOG1)(FastLogTool_1.FLog['Auth'], '[FLog::Auth] Trying to authenticate the user with the placeID %i', placeID);
            AuthenticationHelper.CheckCookieAndPlaceIdInternalAsync(cookie, placeID)
                .then(() => {
                Globals_1.Globals.PlaceID = placeID;
                resumeFunction();
            })
                .catch(errorFunction);
        });
    }
}
exports.AuthenticationHelper = AuthenticationHelper;
/**
 * @internal
 */
AuthenticationHelper._sharedHttpsAgent = new https_1.Agent({ rejectUnauthorized: !FastLogTool_1.FFlag['Debug'] });
